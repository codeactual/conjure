#!/usr/bin/env node

/**
 * Find all casper scripts and spawn() a new casper.js process for each of them.
 *
 * Organize their concurrent output by script, exit w/ non-zero on any error, etc.
 */

var path = require('path');
var spawn = require('child_process').spawn;
var input = require('commander');

var requireComponent = require('../dist/conjure').require;
var Batch = requireComponent('batch');
var each = requireComponent('each');
var shelljs = requireComponent('outer-shelljs').create(require('shelljs'));

var defShellOpt = {silent: true};

input
  .option('-s, --server <script>', 'Test server startup script', String)
  .option('-c, --concurrent <num>', 'casperjs process count [2]', Number, 2)
  .option('-r, --root <dir>', 'Project root directory [cwd]', String, process.cwd())
  .option('-t, --test <dir>', 'Test directory, relative to root [test]', String, 'test')
  .option('-f, --file <regex>', 'Test file regex filter [.js]', String, '\\.js$')
  .option('-g, --grep', 'Test case regex filter [none]', String)
  .option('-b, --bootstrap <file>', 'Bootstrap all test modules [none]', String)
  .parse(process.argv);

testServer = spawn(input.server);
process.on('exit', function() { testServer.kill(); });

var output = {}; // Index `casperjs` output/errors by test.

// Recursively find matching test scripts.
var testDir = input.root + '/' + input.test;
var tests = shelljs.findByRegex(testDir, new RegExp(input.file));

if (!tests.length) {
  process.exit();
}

// If any `casperjs` exits with an error code, `conjure` exits with 1.
var exitsRemain = tests.length;
var allExitOk = true;
function onSpawnExit() {
  if (!--exitsRemain) {
    process.exit(allExitOk ? 0 : 1);
  }
}

var casperArgs = [];

if (input.bootstrap) {
  casperArgs.push('--bootstrap=' + input.bootstrap);
}

if (input.grep) {
  casperArgs.push('--grep');
  casperArgs = casperArgs.concat(input.args);
}

// Queue one runCasper() call per test script.
var batch = new Batch();
batch.concurrency(input.concurrency);
each(tests, function(test) {
  batch.push(function(taskDone) {
    runCasper(test, taskDone);
  });
});
batch.end(); // Start dequeuing.

/**
 * Run `casperjs`.
 *
 * @param {string} file
 * @param {function} cb Fires after `casperjs` exits.
 */
function runCasper(file, cb) {
  var noTestsRan = false;

  var testRelPath = file.replace(testDir, '');
  output[testRelPath] = [];
  function formatData(data) { return testRelPath + ': ' + data.toString().trim(); }

  var casper = spawn(
    'casperjs',
    [__dirname + '/../bootstrap.js'].concat(
      '--rootdir=' + input.root,
      '--file=' + file,
      casperArgs
    )
  );

  casper.stdout.on('data', function (data) {
    if (/Looks like you didn't run any test/.test(data.toString())) {
      noTestsRan = true;
    }
    output[testRelPath].push({data: data.toString()});
  });

  casper.stderr.on('data', function (data) {
    output[testRelPath].push({err: true, data: data.toString()});
  });

  casper.on('exit', function (code) {
    // Skip output when --grep excluded a file's entire suite.
    if (!noTestsRan || !input.grep) {
      each(output[testRelPath], function(log) {
        if (log.err) {
          console.error(formatData(log.data));
        } else {
          console.log(formatData(log.data));
        }
      });
    }
    allExitOk = allExitOk && 0 === code;
    onSpawnExit();
    cb();
  });
}

function onCasperData(data) {
}
