#!/usr/bin/env node

/**
 * Find all casper scripts and spawn() a new casper.js process for each of them.
 *
 * Organize their concurrent output by script, exit w/ non-zero on any error, etc.
 */

var path = require('path');
var util = require('util');
var sprintf = util.format;
var spawn = require('child_process').spawn;
var input = require('commander');

var requireComponent = require('../dist/conjure').require;
var Batch = requireComponent('batch');
var each = requireComponent('each');
var shelljs = requireComponent('outer-shelljs').create(require('shelljs'));

var defShellOpt = {silent: true};

input
  .option('-s, --server <script>', 'Test server startup script', String)
  .option('-c, --concurrent <num>', 'casperjs process count [2]', Number, 2)
  .option('-r, --root-dir <dir>', 'Project root directory [cwd]', String, process.cwd())
  .option('-t, --test-dir <dir>', 'Test directory, relative to root [test]', String, 'test')
  .option('-f, --grep-file <regex>', 'Test file regex filter [.js]', String, '\\.js$')
  .option('-b, --bootstrap <file>', 'Bootstrap all test modules [none]', String)
  .option('-T, --timeout <ms>', 'Max run time of a casperjs process', Number, 5000)
  .option('-v, --verbose')
  .option('-g, --grep-case', 'Filter test cases with RegExp built from arguments [none]')
  .option('-G, --grepv-case', 'Omit test cases with RegExp built from arguments [none]')
  .parse(process.argv);

if (!input.server) {
  input.outputHelp();
  process.exit(1);
}

var verbose = !input.verbose ? function() {} : function() {
  util.debug(sprintf( // Use debug() over log() to block.
    '[%s] %s',
    (new Date()).toUTCString(),
    sprintf.apply(util, arguments)
  ));
};

testServer = spawn(input.server);
process.on('exit', function() { testServer.kill(); });

var output = {}; // Index `casperjs` output/errors by test.
var status = {}; // Index internal status JSON strings by type.
var statusRe = /^conjure:([^:]+):(.*)$/;

// Recursively find matching test scripts.
// Use cd() so we can just apply --grep-file to paths relative to the test dir.
var testDir = input.rootDir + '/' + input.testDir;
verbose('Test directory: %s', testDir);

if (!shelljs._('test', '-d', testDir)) {
  console.error('Test directory not found: ' + testDir);
  process.exit(1);
}
shelljs._('cd', testDir);


var grepFileRe = new RegExp(input.grepFile);
var tests = shelljs.findByRegex('.', grepFileRe);

if (!tests.length) {
  verbose('No test files match %s', grepFileRe);
  process.exit();
}

// Resolve the test file paths after removing them just for the --grep-file.
tests = tests.map(function(file) { return testDir + '/' + file; });
verbose('Test files matching %s: %s', grepFileRe, tests.join(', '));

// If any `casperjs` exits with an error code, `conjure` exits with 1.
var exitsRemain = tests.length;
var allExitOk = true;
function onSpawnExit() {
  if (!--exitsRemain) {
    process.exit(allExitOk ? 0 : 1);
  }
  verbose('waiting for %s casperjs processes to finish', exitsRemain);
}

var casperArgs = [];

if (input.bootstrap) {
  casperArgs.push('--bootstrap=' + input.bootstrap);
}

if (input.grepCase) {
  casperArgs.push('--grep');
  casperArgs = casperArgs.concat(input.args);
} else if (input.grepvCase) {
  casperArgs.push('--grepv');
  casperArgs = casperArgs.concat(input.args);
}

// Queue one runCasper() call per test script.
var batch = new Batch();
batch.concurrency(input.concurrency);
each(tests, function(test) {
  batch.push(function(taskDone) {
    runCasper(test, taskDone);
  });
});
batch.end(); // Start dequeuing.

/**
 * Run `casperjs`.
 *
 * @param {string} file
 * @param {function} cb Fires after `casperjs` exits.
 */
function runCasper(file, cb) {
  var noTestsRan = false;

  var testRelPath = file.replace(testDir, '');
  output[testRelPath] = [];

  var combinedArgs = [__dirname + '/../bootstrap.js'].concat(
    '--rootdir=' + input.rootDir,
    '--testdir=' + input.testDir,
    '--testfile=' + file,
    casperArgs
  );
  verbose('spawn: casperjs %s', combinedArgs.join(' '));

  var casper = spawn('casperjs', combinedArgs);

  casper.stdout.on('data', function(data) {
    data = data.toString().trim();

    if (/Looks like you didn't run any test/.test(data)) {
      verbose('No matching tests: %s', file);
      noTestsRan = true;
    }

    var statusMatch = data.match(statusRe);
    if (statusMatch) {
      var type = statusMatch[1];
      status[type] = status[type] || [];
      status[type].push(statusMatch[2]);
      return;
    }

    output[testRelPath].push({data: data});
  });

  casper.stderr.on('data', function(data) {
    output[testRelPath].push({err: true, data: data.toString()});
  });

  casper.on('exit', function(code) {
    // Skip output when --grep[v]-case excluded a file's entire suite.
    if (!noTestsRan || (!input.grepCase && !input.grepvCase)) {
      each(output[testRelPath], function(log) {
        if (log.err) {
          stderr(log.data);
        } else {
          stdout(log.data);
        }
      });
    }
    verbose('%s exited with code %d', file, code);
    allExitOk = allExitOk && 0 === code;
    onSpawnExit();
    cb();
  });

  if (input.timeout) {
    setTimeout(function() {
      allExitOk = false;
      casper.kill();
      stdout('Auto-killed %s after %dms timeout', file, input.timeout);

      var waitStatus = lastStatus('wait');
      if (waitStatus) {
        stdout('Potential timeout reason: %s', waitStatus);
      }
    }, input.timeout);
  }

  function formatData() {
    var args = [].slice.call(arguments);
    args[0] = testRelPath + ': ' + args[0];
    return sprintf.apply(null, args);
  }

  function stdout() { console.log(formatData.apply(null, arguments)); }
  function stderr() { console.error(formatData.apply(null, arguments)); }
}

function lastStatus(type) {
  var list = status[type];
  return list && list.length ? list[list.length - 1] : null;
}
