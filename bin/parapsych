#!/usr/bin/env node

var requireComponent = require('../dist/parapsych').require;
var input = require('commander');
var Batch = requireComponent('batch');
var each = requireComponent('each');
var shelljs = requireComponent('outer-shelljs').create(require('shelljs'));

var defShellOpt = {silent: true};

input
  .option('-s, --server <script>', 'Test server startup script', String)
  .option('-c, --concurrent <num>', 'casperjs process count [2]', Number, 2)
  .option('-P, --pid <file>', '', String, '[/tmp/parapsych.pid]')
  .option('-r, --root <dir>', 'Project root directory [cwd]', String, process.cwd())
  .option('-t, --test <dir>', 'Test directory, relative to root [test]', String, 'test')
  .option('-f, --file <regex>', 'Test file regex filter [.js]', String, '/\\.js$')
  .option('-g, --grep <pattern>', 'Test case regex filter [none]', String)
  .parse(process.argv);

killLastPid(); // In case last session exited ungracefully.
startTestServer();
spawnOneCasperPerFile();
process.on('exit', function() {
  console.log('exiting');
  killLastPid();
});

function startTestServer() {
  shelljs._('exec', input.server, {async: true, silent: true});
  //require('child_process').fork(input.server);
}

/**
 * Find all casper scripts and spawn() a new casper.js process for each of them.
 *
 * Organize their concurrent output by script, exit w/ non-zero on any error, etc.
 */
function spawnOneCasperPerFile() {
  console.log('spawnOneCasperPerFile');
  var path = require('path');
  var spawn = require('child_process').spawn;

  var testDir = input.root + '/' + input.test;
  var tests = shelljs.findByRegex(testDir, new RegExp(input.file));

  // If one spawn() exits with an error code, also exit this process with one.
  var exitsRemain = tests.length;
  var allExitOk = true;
  var onSpawnExit = function() {
    if (!--exitsRemain) {
      process.exit(allExitOk ? 0 : 1);
    }
  };

  var output = {};

  function spawnOne(test, done) {
    var label = test.replace(testDir, '');
    output[label] = [];

    var noTestsRan = false;

    var casper = spawn(
      'casperjs',
      [test].concat('--rootdir=' + input.root)
    );
    var formatData = function(data) {
      return label + ': ' + data.toString().trim();
    };
    casper.stdout.on('data', function (data) {
      if (/Looks like you didn't run any test/.test(data.toString())) {
        noTestsRan = true;
      }
      output[label].push({data: data.toString()});
    });
    casper.stderr.on('data', function (data) {
      output[label].push({err: true, data: data.toString()});
    });
    casper.on('exit', function (code) {
      // Skip output when --grep excluded a file's entire suite.
      if (!noTestsRan || !input.grep) {
        each(output[label], function(log) {
          if (log.err) {
            console.error(formatData(log.data));
          } else {
            console.log(formatData(log.data));
          }
        });
      }
      allExitOk = allExitOk && 0 === code;
      onSpawnExit();
      done();
    });
  }

  var batch = new Batch();
  batch.concurrency(input.concurrency);
  each(tests, function(test) {
    batch.push(function(taskDone) {
      spawnOne(test, taskDone);
    });
  });

  batch.end(function() {
    console.log('batch done');
  });
}

function killLastPid() {
  if (shelljs._('test', '-e', input.pid)) {
    shelljs._('exec', 'kill -9 ' + input.pid, defShellOpt);
    shelljs._('rm', '-f', input.pid);
  }
}
